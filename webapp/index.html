<!-- ECE 441 Fall 2025 -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smart Shade</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <style>
    :root
    {
      --bg: #eae7f5;
      --card: #fefcff;
      --accent: #3b228a;
      --accent-soft: #e6dbff;
      --muted: #f7f4ff;
      --text: #222;
      --danger: #a00;
    }

    * { box-sizing: border-box; }

    html, body { height: 100%; }

    body 
    {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background-color: var(--bg);
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0;
      color: var(--text);
    }

    /* Phone frame container */
    .phone-frame 
    {
      width: 390px; /* iPhone 12/13 mini width */
      height: 760px;
      background: var(--card);
      border-radius: 32px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .header 
    {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.9rem 2.75rem; /* leave room for gear */
      border-bottom: 1px solid #eee;
      position: relative;
    }

    .header h1 { font-size: 1.25rem; margin: 0; color: var(--accent); }

    .gear-btn 
    {
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      cursor: pointer;
    }
    .gear-btn .material-icons { font-size: 26px; color: var(--accent); vertical-align: middle; }

    .card .row 
    {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .card .row .btn 
    {
      flex: 1 1 calc(33.3% - 0.5rem);
      min-width: 100px;
      text-align: center;
      justify-content: center;
    }

    .container 
    {
      padding: 1rem 1.25rem 0.5rem 1.25rem;
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* Shared UI pieces */
    h2 { font-size: 1.1rem; margin: 0 0 0.5rem; color: var(--accent); }
    p { font-size: 0.98rem; line-height: 1.45; }

    .card 
    {
      background: var(--muted);
      border-radius: 12px;
      padding: 0.9rem;
      margin: 0.6rem 0;
    }

    .row { display: flex; align-items: center; gap: 0.5rem; }
    .row.space { justify-content: space-between; }
    .col { display: flex; flex-direction: column; gap: 0.5rem; }

    .btn 
    {
      background-color: var(--accent-soft);
      color: var(--accent);
      border: none;
      border-radius: 12px;
      padding: 0.6rem 0.95rem;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      cursor: pointer;
      transition: transform 0.05s ease, background-color 0.2s ease;
      user-select: none;
      touch-action: manipulation;
    }

    .btn:hover { background-color: #d8caff; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: var(--accent); color: #fff; }
    .btn.danger { color: #fff; background: #c43a3a; }

    .icon { font-family: 'Material Icons'; font-size: 22px; }

    input[type="range"] { width: 100%; accent-color: #7b4cff; }
    input[type="time"], select, input[type="number"], input[type="text"] 
    {
      width: 100%;
      padding: 0.55rem 0.7rem;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 0.95rem;
      background: #fff;
    }

    .list { max-height: 180px; overflow-y: auto; }

    .list-item 
    {
      background: #fff;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 0.55rem 0.7rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 0.4rem 0;
    }

    .delete { background: transparent; border: none; color: var(--danger); cursor: pointer; }

    .summary-box { background: var(--muted); border-radius: 12px; padding: 0.8rem; font-size: 0.95rem; }
    .statusline { font-size: 0.9rem; color: #555; margin: 0.25rem 0; }

    /* Wizard nav */
    .nav { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.8rem 0.8rem; border-top: 1px solid #eee; }
    .arrow-btn { background: none; border: none; cursor: pointer; }
    .arrow-btn .material-icons { font-size: 36px; color: var(--accent); }

    .hidden { display: none !important; }

    /* Simple modal */
    .modal-backdrop 
    {
      position: absolute; inset: 0; background: rgba(0,0,0,0.35);
      display: flex; align-items: flex-end; justify-content: center;
      padding: 1rem; z-index: 10;
    }

    .modal { width: 100%; max-width: 380px; background: #fff; border-radius: 16px; padding: 0.9rem; }
    .modal h3 { margin: 0 0 0.5rem; font-size: 1.05rem; color: var(--accent); }
  </style>
</head>
<body>
    <div class="phone-frame">
        <div class="header">
            <h1 id="title">Smart Shade</h1>
            <button id="gearBtn" class="gear-btn" aria-label="Settings"><span class="material-icons">settings</span></button>
        </div>

        <div class="container">
            <!-- Wizard Root -->
            <div id="wizardRoot" class="hidden"></div>

            <!-- Control Panel Root -->
            <div id="panelRoot" class="hidden">
                <!-- Status card -->
                <div class="card">
                    <h2>Status</h2>
                    <div class="statusline">Mode: <strong id="modeDisplay">—</strong></div>
                    <div class="statusline">Active Shade: <strong id="shadeDisplay">—</strong></div>
                    <div class="statusline">Current Step: <strong id="stepDisplay">0</strong></div>
                </div>

                <!-- Mode Controls -->
                <div class="card">
                    <h2>Mode</h2>
                    <div class="row">
                        <button class="btn" onclick="setMode('auto')"><span class="icon">autorenew</span>Auto</button>
                        <button class="btn" onclick="setMode('manual')"><span class="icon">touch_app</span>Manual</button>
                        <button class="btn" onclick="setMode('schedule')"><span class="icon">schedule</span>Schedule</button>
                    </div>
                    <div class="statusline hidden" id="scheduleHint">You are in schedule mode. Your schedules are listed below. Use the top-right <b>gear</b> to edit schedules.</div>
                </div>

                <!-- Blind Controls (manual only) -->
                <div id="blindsCard" class="card hidden">
                    <h2>Blinds</h2>
                    <div class="row">
                        <button id="btnUp" class="btn"><span class="icon">north</span>Up</button>
                        <button id="btnDown" class="btn"><span class="icon">south</span>Down</button>
                        <button class="btn" onclick="swapBlind()"><span class="icon">swap_horiz</span>Swap</button>
                    </div>
                </div>

                <!-- Sensors (auto only) -->
                <div id="sensorsCard" class="card hidden">
                    <h2>Sensors</h2>
                    <div class="row space">
                        <div class="statusline">Light readings</div>
                        <button class="btn" onclick="refreshSensors()"><span class="icon">refresh</span>Refresh</button>
                    </div>
                    <div id="sensorContainer" class="list">Shown in Auto mode</div>
                </div>

                <!-- Schedule list (visible in schedule mode) -->
                <div id="scheduleListCard" class="card hidden">
                    <h2>Active Schedules</h2>
                    <div id="activeScheduleList" class="list">No schedules configured.</div>
                </div>
            </div>
        </div>

        <!-- Wizard nav (shown/hidden dynamically) -->
        <div id="wizardNav" class="nav hidden">
            <button class="arrow-btn" id="nextBtn"><span class="material-icons">arrow_forward_ios</span></button>
        </div>

        <!-- Settings modal (gear) -->
        <div id="settingsModal" class="modal-backdrop hidden">
            <div class="modal">
                <h3>Settings</h3>
                <div class="col">
                    <button class="btn" id="enterSetupBtn"><span class="icon">build</span>Enter Setup</button>
                    <button class="btn" id="configSchedulesBtn"><span class="icon">event</span>Configure Schedules</button>
                    <button class="btn primary" id="saveSettingsBtn" onclick="savePanelConfig()"><span class="icon">save</span>Save Settings</button>
                    <button class="btn" id="closeSettings"><span class="icon">close</span>Close</button>
                    <div id="settingsSaveMsg" class="statusline"></div>
                </div>
            </div>
        </div>

        <!-- Confirm re-enter setup modal -->
        <div id="confirmModal" class="modal-backdrop hidden">
            <div class="modal">
                <h3>Re-enter Setup?</h3>
                <p>Proceeding will <b>wipe your current settings</b>. Are you sure?</p>
                <div class="row">
                    <button class="btn" id="cancelConfirm"><span class="icon">close</span>Cancel</button>
                    <button class="btn danger" id="confirmSetup"><span class="icon">warning</span>Yes, enter setup</button>
                </div>
            </div>
        </div>

        <!-- Schedule editor modal -->
        <div id="schedModal" class="modal-backdrop hidden">
            <div class="modal">
                <h3>Schedule Configuration</h3>
                <div class="card" style="background:#f9f9ff;">
                    <div class="row" style="gap:0.5rem; flex-wrap:wrap;">
                        <input type="time" id="mTime" />
                        <select id="mMotor">
                            <option value="sunshade">Sunshade</option>
                            <option value="blackout">Blackout</option>
                        </select>
                        <select id="mLevel"></select>
                        <button id="mAdd" class="btn"><span class="icon">add</span></button>
                    </div>
                    <div id="mList" class="list" style="margin-top:0.5rem;"></div>
                </div>
                <div class="row">
                    <button class="btn" id="mClose"><span class="icon">close</span>Close</button>
                    <button class="btn primary" id="mSave"><span class="icon">save</span>Save</button>
                </div>
            </div>
        </div>
    </div>



    <!-- -------------------------------------------------- -->
    <!-- NOW ENTERING SCRIPT ZONE -- PLEASE WIPE YOUR SHOES -->
    <!-- -------------------------------------------------- -->



    <script>
        /* ------------------------------------------------------------------
         * Global state
         * ------------------------------------------------------------------ */
        const POLL_MS = 3000;
        let pollTimer = null;

        // Shared status (from /api/status)
        const statusState = { mode: 'auto', active_shade: 'sunshade', step: 0 };

        // Wizard state
        let currentStep = 0;
        let motorSteps = { 1: 0, 2: 0 };
        let sensorSteps = [];            // [{step:number}]
        let schedules = [];              // [{time, motor:'sunshade'|'blackout', level:'1'..}]
        let threshold = 2500;
        let light = 48;                  // demo for UI only

        const config =
        {
            motors: [null, null],
            sensor_steps: [],
            threshold: 2500
        };

        // Snappy helper functions to simplify code a bit
        function qs(id) { return document.getElementById(id); }
        function show(el) { el.classList.remove('hidden'); }
        function hide(el) { el.classList.add('hidden'); }

        /**
        * Builds a JSON of the active settings, to be sent to the client.
        */
        function makeSettingsPayload()
        {
            return {
                op_mode: statusState.mode,
                active_shade: statusState.active_shade,
                step: statusState.step,
                threshold: threshold,
                sensor_steps: sensorSteps.map(s => s.step)
            };
        }

        /** 
        * Transforms the given button into a repeatable button (hold to repeat).
        * Useful for manual controls.
        */
        function makeRepeatable(button, onTick, interval = 140) {
            let t = null;
            // listen for the button to begin being touched (see below for the event listener)
            const start = (e) =>
            {
                e.preventDefault();
                if (t) return;
                onTick();
                t = setInterval(onTick, interval);
            };
            // and listen for the button no longer being touched
            const stop = () =>
            {
                if (t)
                {
                    clearInterval(t);
                    t = null;
                }
            };
            button.addEventListener('mousedown', start);
            button.addEventListener('touchstart', start, { passive: false });
            ['mouseup', 'mouseleave', 'touchend', 'touchcancel'].forEach(ev => button.addEventListener(ev, stop));
        }

        /**
        * Transition to the setup wizard, hiding the main interface if it is active.
        */
        function showWizard()
        {
            show(qs('wizardRoot'));
            show(qs('wizardNav'));
            hide(qs('panelRoot'));
            hide(qs('gearBtn'));
            qs('title').textContent = 'Smart Shade • Setup';
            // figure out what step of setup we are on and render that
            renderStep();
        }

        /** 
        * Depending on the active mode, show its panel on the main interface.
        */
        function paintPanelVisibility()
        {
            const isAuto = statusState.mode === 'auto';
            const isManual = statusState.mode === 'manual';
            const isSchedule = statusState.mode === 'schedule';

            (isAuto ? show : hide)(qs('sensorsCard'));
            (isManual ? show : hide)(qs('blindsCard'));
            (isSchedule ? show : hide)(qs('scheduleListCard'));
            qs('scheduleHint').classList.toggle('hidden', !isSchedule);
        }

        /**
        * Organize the list of active schedules in its panel.
        */
        function paintScheduleList()
        {
            const list = qs('activeScheduleList');
            if (!list) return;
            list.innerHTML = schedules.length
                ? schedules.map(s => `<div class='list-item'>${s.time} — ${s.motor === 'sunshade' ? 'Sunshade' : 'Blackout'} → Sensor ${s.level}</div>`).join('')
                : 'No schedules configured.';
        }

        /**
        * Transition to the main interface, hiding the setup panel if it is active.
        */
        function showPanel()
        {
            hide(qs('wizardRoot'));
            hide(qs('wizardNav'));
            show(qs('panelRoot'));
            show(qs('gearBtn'));
            qs('title').textContent = 'Smart Shade • Control';
            updateStatus().then(() => { paintPanelVisibility(); paintScheduleList(); });
            refreshSensors();
        }

        /** 
        * Capitalize the first letter of a given string. Used for clean display of mode and blind names.
        * @param {string} sentence
        */
        function capitalize(sentence)
        {
            return sentence.charAt(0).toUpperCase() + sentence.slice(1);
        }

        /**
        * Upon receiving a status update, switch between the main interface and the setup wizard if necessary.
        */
        async function decideView()
        {
            try
            {
                await updateStatus();
                if (statusState.mode === 'setup') showWizard(); else showPanel();
            }
            catch (e)
            {
                console.error('Failed to decide view:', e); showPanel();
            }
        }

        //
        // API Calls (instruct the client to do stuff)
        //

        /**
        * Send an API call to obtain the device status from the client.
        */
        async function updateStatus()
        {
            const res = await fetch('/api/status');
            const data = await res.json();
            statusState.mode = data.mode;
            statusState.active_shade = data.active_shade;
            statusState.step = data.step;

            // update various UI elements based on this information
            if (qs('modeDisplay'))
            {
                qs('modeDisplay').textContent = capitalize(statusState.mode);
                qs('shadeDisplay').textContent = capitalize(statusState.active_shade);
                qs('stepDisplay').textContent = statusState.step;
            }

            paintPanelVisibility();
            return data;
        }

        /**
        * Send an API call to instruct the client to change modes.
        * @param {string} mode 'auto', 'manual', 'schedule', or 'setup'
        */
        async function setMode(mode)
        {
            // When explicitly requesting setup, always reset the wizard to the first page.
            if (mode === 'setup') currentStep = 0;

            await fetch('/api/mode', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode }) });
            await updateStatus();
            if (statusState.mode === 'setup') showWizard(); else showPanel();
        }

        /**
        * Send an API call to instruct the client to move the blind up or down.
        * From this end, movement is done 10 steps at a time because each step is so small. Thus only direction must be specified.
        * @param {string} direction 'up' or 'down'
        */
        async function move(direction)
        {
            await fetch('/api/move', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ direction, steps: 10 }) });
            updateStatus();
        }

        /**
        * Send an API call to instruct the client to move the blind up or down.
        * From this end, movement is done 10 steps at a time because each step is so small. Thus only direction must be specified.
        * This movement function is unsafe in that it ignores operation limits of the blind. It is only used for setup.
        * @param {string} direction 'up' or 'down'
        */
        async function move_unsafe(direction) {
            await fetch('/api/move_unsafe', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ direction, steps: 10 }) });
            updateStatus();
        }

        /**
        * Send an API call to instruct the client to swap the active blind.
        */
        async function swapBlind()
        {
            try
            {
                await fetch('/api/swap', { method: 'POST' });
                updateStatus();
            }
            catch (e)
            {
                console.error('Swap failed', e);
            }
        }

        /**
        * Send an API call to instruct the client to fetch sensor readings and return them to the web app.
        * This only actually does anything if the blind is in auto mode.
        */
        async function refreshSensors()
        {
            if (statusState.mode !== 'auto') return; // only fetch/paint in auto
            const res = await fetch('/api/sensors');
            const data = await res.json();
            const container = qs('sensorContainer'); if (!container) return;
            container.innerHTML = '';

            // Render sensors in reverse order so sensor 1 is shown at the bottom
            for (let i = data.readings.length - 1; i >= 0; i--) {
                const r = data.readings[i];
                const div = document.createElement('div');
                div.className = 'list-item';
                div.textContent = `Sensor ${i + 1}: ${r === null ? 'N/A' : r.toFixed(2) + ' lux'}`;
                container.appendChild(div);
            }
        }

        /**
        * Send an API call to instruct the client to save the active settings and schedules.
        */
        async function save(settings, schedulesPayload)
        {
            const res = await fetch('/api/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ settings, schedules: schedulesPayload }) });
            return res.ok;
        }

        /**
        * Render the "config saved" message that pops up at the end of setup.
        */
        async function savePanelConfig()
        {
            const settings = makeSettingsPayload();
            const ok = await save(settings, schedules);
            const msg = qs('settingsSaveMsg');
            if (msg) msg.textContent = ok ? '? Configuration saved successfully! Returning to main menu...' : '? Failed to save configuration.';
            setTimeout(() => { if (msg) msg.textContent = ''; }, 3500);
            if (statusState.mode === 'schedule') paintScheduleList();
        }

        /* ------------------------------------------------------------------
         * Settings gear + modals
         * ------------------------------------------------------------------ */
        qs('gearBtn').addEventListener('click', () => show(qs('settingsModal')));
        qs('closeSettings').addEventListener('click', () => hide(qs('settingsModal')));

        // Enter setup with confirmation
        qs('enterSetupBtn').addEventListener('click', () => { hide(qs('settingsModal')); show(qs('confirmModal')); });
        qs('cancelConfirm').addEventListener('click', () => hide(qs('confirmModal')));
        qs('confirmSetup').addEventListener('click', async () => {
            hide(qs('confirmModal'));
            // Optionally clear local UI state – backend will wipe authoritative config
            motorSteps = { 1: 0, 2: 0 }; sensorSteps = []; schedules = []; threshold = 2500; config.motors = [null, null];
            // Ensure wizard will start on first page when setup is entered
            currentStep = 0;
            await setMode('setup');
        });

        // Open schedule editor
        function paintSchedEditor()
        {
            const level = qs('mLevel');
            // Populate options in reverse order (highest sensor first)
            if (sensorSteps.length)
            {
                let opts = '';
                for (let i = sensorSteps.length; i >= 1; i--)
                {
                    opts += `<option value='${i}'>Sensor ${i}</option>`;
                }
                level.innerHTML = opts;
            }
            else
            {
                level.innerHTML = `<option disabled>No Sensors added</option>`;
            }
            const list = qs('mList');
            list.innerHTML = schedules.length ? schedules.map((s, i) => `
                <div class='list-item'>
                <div><strong>${s.time}</strong> — ${s.motor === 'sunshade' ? 'Sunshade' : 'Blackout'} → Sensor ${s.level}</div>
                <button class='delete' data-i='${i}'><span class='icon'>delete</span></button>
                </div>`).join('') : 'No schedules yet.';
            list.querySelectorAll('.delete').forEach(b => b.addEventListener('click', () => { const i = +b.getAttribute('data-i'); schedules.splice(i, 1); paintSchedEditor(); }));
        }

        function openScheduleEditor() { paintSchedEditor(); show(qs('schedModal')); }

        qs('configSchedulesBtn').addEventListener('click', () => { hide(qs('settingsModal')); openScheduleEditor(); });
        qs('mClose').addEventListener('click', () => hide(qs('schedModal')));
        qs('mAdd').addEventListener('click', () => {
            const t = qs('mTime').value; const m = qs('mMotor').value; const l = qs('mLevel').value;
            if (!t || !m || !l) return;
            schedules.push({ time: t, motor: m, level: l });
            qs('mTime').value = '';
            paintSchedEditor();
            paintScheduleList();
        });
        qs('mSave').addEventListener('click', async () => {
            const settings = makeSettingsPayload();
            const ok = await save(settings, schedules);
            if (ok) hide(qs('schedModal'));
            paintScheduleList();
        });

        /**
        * Strings for the setup wizard to use.
        */
        const steps =
        [
            {
                title: 'Smart Shade Setup',
                subtitle: 'Welcome!',
                body: `This wizard will guide you in setting up the configuration for your Smart Shade.<br><b>Be careful while configuring these settings, as it will not be possible to redo any steps without restarting the setup process.</b><br><br>Before continuing, please ensure all light sensors you want to use are plugged into the device.<br><br>Use the arrow below when you are ready to proceed.`,
                renderExtras: () => ''
            },
            {
                title: 'Smart Shade Setup',
                subtitle: 'Calibration (Sunshade)',
                body: `First, set the Sunshade <b>fully up</b> using the controls below.`,
                renderExtras: () => `
                    <div class=\"row\" style=\"justify-content:center; gap:1rem; margin-top:0.6rem;\">
                    <button id=\"wUp1\" class=\"btn\"><span class=\"icon\">north</span>Up</button>
                    <button id=\"wDown1\" class=\"btn\"><span class=\"icon\">south</span>Down</button>
                    </div>`, motor: 1
            },
            {
                title: 'Smart Shade Setup',
                subtitle: 'Calibration (Blackout)',
                body: `Next, set the Blackout Shade <b>fully up</b> using the controls below.<br>It should be perfectly level with the Sunshade.`,
                renderExtras: () => `
                    <div class=\"row\" style=\"justify-content:center; gap:1rem; margin-top:0.6rem;\">
                    <button id=\"wUp2\" class=\"btn\"><span class=\"icon\">north</span>Up</button>
                    <button id=\"wDown2\" class=\"btn\"><span class=\"icon\">south</span>Down</button>
                    </div>`, motor: 2
            },
            {
                title: 'Smart Shade Setup',
                subtitle: 'Sensor Positions',
                body: `Place your light sensors on the window frame.<br>You may space them however you like, but please ensure they are placed in order of port: port 0 should be the bottommost sensor, port 1 should be the next highest, and so on.<br><br>Once the sensors are in place, use the controls below to line the blind up with each sensor's position, starting from the bottommost sensor.<br>Once the blind is level with a sensor, use the 'Add Sensor' button to save that sensor's position.<br><br>Continue once the positions of all sensors have been saved.`,
                renderExtras: () => `
                    <div class=\"card\" style=\"margin-top:0.4rem;\">
                    <div class=\"row space\">
                    <div><b>Sunshade step</b>: <span id=\"motorStep1b\">${motorSteps[1]}</span></div>
                    <div class=\"row\">
                    <button id=\"wUp3\" class=\"btn\"><span class=\"icon\">north</span></button>
                    <button id=\"wDown3\" class=\"btn\"><span class=\"icon\">south</span></button>
                    </div>
                    </div>
                    <div class=\"row\" style=\"justify-content:center; margin-top:0.5rem;\">
                    <button id=\"addSensorBtn\" class=\"btn\"><span class=\"icon\">add</span>Add Sensor</button>
                    </div>
                    <div id=\"sensorList\" class=\"list\" style=\"margin-top:0.5rem;\"></div>
                    </div>`, sensor_steps: true
            },
            {
                title: 'Smart Shade Setup',
                subtitle: 'Light Sensitivity',
                body: `You may adjust the sensitivity of the light sensors if you are in an overcast or particularly bright area.<br>A higher reading indicates a greater amount of light.<br><br>If you are unsure, <b>2500</b> is typically a good amount.`,
                renderExtras: () => `
                    <div class=\"card\">
                    <div style=\"font-size:1.4rem; font-weight:700; text-align:center;\" id=\"thresholdValue\">${threshold}</div>
                    <input type=\"range\" id=\"thresholdSlider\" min=\"0\" max=\"10000\" step=\"250\" value=\"${threshold}\">
                    </div>`, threshold: true
            },
            {
                title: 'Smart Shade Setup',
                subtitle: '(Optional) Schedule Configuration',
                body: 'You may schedule actions for the shade to perform automatically when it is in Schedule Mode.<br>This can be completed or added to at a later time.',
                renderExtras: () => `
                    <div class=\"card\">
                    <div class=\"row\" style=\"gap:0.5rem; flex-wrap:wrap;\">
                    <input type=\"time\" id=\"scheduleTime\" />
                    <select id=\"scheduleMotor\"><option value=\"sunshade\">Sunshade</option><option value=\"blackout\">Blackout</option></select>
                    <select id=\"scheduleLevel\"></select>
                    <button id=\"addScheduleBtn\" class=\"btn\"><span class=\"icon\">add</span></button>
                    </div>
                    <div id=\"scheduleList\" class=\"list\" style=\"margin-top:0.5rem;\"></div>
                    </div>`, schedules: true
            },
            {
                title: 'Smart Shade Setup',
                subtitle: 'Review & Save',
                body: 'Setup is now complete.<br>Review the settings below and press “Save Configuration” to apply them.<br><br>If any errors have been made, please repeat the setup process.',
                renderExtras: () => `
                    <div id=\"summaryBox\" class=\"summary-box\" style=\"margin-top:0.5rem;\"></div>
                    <div class=\"row\" style=\"justify-content:center; margin-top:0.6rem;\">
                    <button id=\"saveBtn\" class=\"btn primary\"><span class=\"icon\">save</span>Save Configuration</button>
                    </div>
                    <div id=\"saveNotice\" class=\"statusline\" style=\"text-align:center; margin-top:0.4rem;\"></div>`, summary: true
            },
        ];

        /**
        * Renders the current step of the setup wizard.
        */
        function renderStep()
        {
            // Purpose: Render the current wizard step into the DOM.
            // - `currentStep` indexes the `steps` array.
            // - This function rebuilds the wizard content each time it is called
            //   and wires up the interactive controls for that step.
            const root = qs('wizardRoot'); const s = steps[currentStep];

            // Insert the card HTML for the current step (title, subtitle, body, extras)
            root.innerHTML = `<div class="card"><h2>${s.title}</h2><div class="statusline"><strong>${s.subtitle}</strong></div><p style="margin-top:0.3rem;">${s.body}</p>${s.renderExtras ? s.renderExtras() : ''}</div>`;

            qs('nextBtn').style.visibility = currentStep === steps.length - 1 ? 'hidden' : 'visible';

            // Holdable buttons in wizard
            // hookHold attaches makeRepeatable to buttons so pressing & holding repeatedly
            // invokes the changeStep(delta, motor) function.
            const hookHold = (id, delta, motor) => {
                const b = qs(id);
                if (!b) return;
                makeRepeatable(b, () => changeStep(delta, motor));
            };
            hookHold('wUp1', -10, 1); hookHold('wDown1', 10, 1);
            hookHold('wUp2', -10, 2); hookHold('wDown2', 10, 2);
            hookHold('wUp3', -10, 1); hookHold('wDown3', 10, 1);

            // If this step is tied to a specific motor, ensure that motor is selected
            // in the physical device so user controls affect the expected blind.
            if (s.motor)
            {
                ensureCorrectBlind(s.motor);
            }

            // Sensor steps block:
            // - Render "Add Sensor" UI and list of saved sensor positions.
            // - `paint()` regenerates the sensor list and wires delete handlers.
            // - Clicking Add stores the current sunshade motor step as a sensor position.
            // - ensureSunshadeActive() attempts to make the sunshade active before painting the list.
            if (s.sensor_steps)
            {
                const addBtn = qs('addSensorBtn'); const list = qs('sensorList');
                function paint()
                {
                    // Render sensor list in reverse so sensor 1 appears at the bottom of the list
                    let html = '';
                    for (let i = sensorSteps.length - 1; i >= 0; i--)
                    {
                        const l = sensorSteps[i];
                        html += `<div class='list-item'><div><strong>Sensor ${i + 1}</strong>: ${l.step} steps</div><button class='delete' data-index='${i}'><span class='icon'>delete</span></button></div>`;
                    }
                    list.innerHTML = html;
                    list.querySelectorAll('.delete').forEach(btn => btn.addEventListener('click', () => { const idx = Number(btn.getAttribute('data-index')); sensorSteps.splice(idx, 1); paint(); }));
                }
                addBtn.addEventListener('click', () => {
                    sensorSteps.push({ step: motorSteps[1] });
                    paint();
                });
                paint();
                // Ensure Sunshade is active BEFORE first render of this step
                (async () => {
                    await ensureSunshadeActive();  // uses /api/swap_dumb under the hood
                    paint();
                })();
            }

            // Threshold slider:
            // - If the step exposes a threshold slider, wire up input events to update the
            //   `threshold` variable and update the displayed value in realtime.
            if (s.threshold)
            {
                const slider = qs('thresholdSlider'); const val = qs('thresholdValue');
                slider.addEventListener('input', () => { threshold = parseInt(slider.value, 10); val.textContent = `${threshold}`; });
            }

            // Schedules builder:
            // - Render inputs for schedule time, motor selection, sensor/level.
            // - fillLevelOptions populates available sensor levels (depends on sensorSteps).
            // - paintSchedules shows existing schedules and wires delete buttons.
            // - addBtn adds a schedule object into the `schedules` array and repaints.
            if (s.schedules)
            {
                const timeInput = qs('scheduleTime'); const motorSelect = qs('scheduleMotor'); const levelSelect = qs('scheduleLevel'); const addBtn = qs('addScheduleBtn'); const list = qs('scheduleList');
                const fillLevelOptions = () =>
                {
                    if (sensorSteps.length)
                    {
                        let opts = '';
                        for (let i = sensorSteps.length; i >= 1; i--)
                        {
                            opts += `<option value='${i}'>Sensor ${i}</option>`;
                        }
                        levelSelect.innerHTML = opts;
                    }
                    else
                    {
                        levelSelect.innerHTML = `<option disabled>No Sensors added</option>`;
                    }
                };
                function paintSchedules()
                {
                    list.innerHTML = schedules.map((s, i) => `<div class='list-item'><div><strong>${s.time}</strong> — ${s.motor === 'sunshade' ? 'Sunshade' : 'Blackout'} → Sensor Level ${s.level}</div><button class='delete' data-index='${i}'><span class='icon'>delete</span></button></div>`).join('');
                    list.querySelectorAll('.delete').forEach(btn => btn.addEventListener('click', () => { const idx = btn.getAttribute('data-index'); schedules.splice(idx, 1); paintSchedules(); }));
                }
                addBtn.addEventListener('click', () => { if (!timeInput.value || !levelSelect.value || !motorSelect.value) return; schedules.push({ time: timeInput.value, motor: motorSelect.value, level: levelSelect.value }); paintSchedules(); timeInput.value = ''; });
                fillLevelOptions(); paintSchedules();
            }

            // Summary + save:
            // - When the summary step is active, build a human readable summary of
            //   calibration values, levels, threshold and schedules.
            // - Wire the save button to call saveToPi which persists configuration
            //   and then attempts to switch back to manual mode on success.
            if (s.summary)
            {
                const box = qs('summaryBox'); const saveBtn = qs('saveBtn'); const saveMsg = qs('saveNotice');
                const motor1StepsFinal = config.motors[0] ?? motorSteps[1]; const motor2StepsFinal = config.motors[1] ?? motorSteps[2];

                // Build sensor summary in reverse order (highest sensor first visually)
                let levelsSummary = 'No Sensors added';
                if (sensorSteps.length) {
                    const parts = [];
                    for (let i = sensorSteps.length - 1; i >= 0; i--) {
                        parts.push(`Sensor ${i + 1}: ${sensorSteps[i].step} steps`);
                    }
                    levelsSummary = parts.join('<br>');
                }

                box.innerHTML = `
                    <div class='card'><div><strong>Levels</strong></div>${levelsSummary}</div>
                    <div class='card'><div><strong>Light Sensitivity</strong> ${threshold}</div></div>
                    <div class='card'><div><strong>Schedules</strong></div>${schedules.length ? schedules.map(s => `${s.time} → ${s.motor === 'sunshade' ? 'Sunshade' : 'Blackout'}, Sensor ${s.level}`).join('<br>') : 'No schedules added'}</div>`;

                saveBtn.addEventListener('click', async () => {
                    const settings = makeSettingsPayload();
                    const ok = await save(settings, schedules);
                    if (ok)
                    {
                        saveMsg.textContent = '✅ Configuration saved successfully! Returning to main menu...';
                        try
                        {
                            await fetch('/api/mode', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'manual' }) });
                            statusState.mode = 'manual';
                            setTimeout(() => { showPanel(); }, 1200);
                        }
                        catch (e)
                        {
                            console.error('Failed to switch to manual mode:', e);
                        }
                    }
                    else { saveMsg.textContent = '❌ Failed to save configuration.'; }
                    setTimeout(() => (saveMsg.textContent = ''), 4000);
                });
            }
        }

        function changeStep(delta, motor)
        {
            motorSteps[motor] = motorSteps[motor] + delta;
            document.querySelectorAll(`#motorStep${motor}, #motorStep${motor}b`).forEach(el => (el.textContent = motorSteps[motor]));
            moveDuringSetup(delta < 0 ? 'up' : 'down');
        }

        function moveDuringSetup(direction)
        {
            fetch('/api/move_unsafe', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ direction, steps: 10 })
            }).catch(err => console.error('Setup move failed', err));
        }

        async function ensureCorrectBlind(motor)
        {
            try
            {
                const res = await fetch('/api/status');
                const data = await res.json();
                const active = data.active_shade;
                const desired = motor === 1 ? 'sunshade' : 'blackout';
                if (active !== desired) {
                    await fetch('/api/swap_dumb', { method: 'POST' });
                    await new Promise(r => setTimeout(r, 500));
                }
            }
            catch (e)
            {
                console.error('Failed to ensure correct blind', e);
            }
        }

        async function ensureSunshadeActive()
        {
            try
            {
                const res = await fetch('/api/status');
                const data = await res.json();
                if (data.active_shade !== 'sunshade') {
                    await fetch('/api/swap_dumb', { method: 'POST' });
                    await new Promise(r => setTimeout(r, 500));
                }
            }
            catch (e)
            {
                console.error('Failed to set sunshade active', e);
            }
        }

        // Wizard nav
        qs('nextBtn').addEventListener('click', async () => {
            if (currentStep === 1) { config.motors[0] = motorSteps[1]; motorSteps[1] = 0; }
            if (currentStep === 2)
            {
                config.motors[1] = motorSteps[2];
                motorSteps[2] = 0;
                try {
                    const res = await fetch('/api/zero_step', { method: 'POST' });
                    const payload = await res.json().catch(() => ({}));
                    if (!res.ok) {
                        console.error('zero_step returned error', payload);
                    } else {
                        // backend uses a single shared step counter — update UI only after server confirms
                        motorSteps[1] = 0;
                        motorSteps[2] = 0;
                        console.debug('Motors zeroed on server:', payload);
                    }
                } catch (e) {
                    console.error('Failed to call /api/zero_step:', e);
                    // leave local values intact so user can retry or inspect
                }
            }

            if (currentStep < steps.length - 1) currentStep++; renderStep();
        });

        /* ------------------------------------------------------------------
         * App bootstrap & polling
         * ------------------------------------------------------------------ */
        async function bootstrap()
        {
            // Make Up/Down buttons holdable in panel
            makeRepeatable(qs('btnUp'), () => move('up'));
            makeRepeatable(qs('btnDown'), () => move('down'));

            await decideView();
            if (pollTimer) clearInterval(pollTimer);
            pollTimer = setInterval(async () => {
                const oldMode = statusState.mode;
                try
                {
                    await updateStatus();
                    if (oldMode !== statusState.mode) { if (statusState.mode === 'setup') showWizard(); else showPanel(); }
                    if (statusState.mode === 'auto') refreshSensors();
                }
                catch (e)
                {
                    console.warn('Polling failed:', e);
                }
            }, POLL_MS);
        }

        bootstrap();
    </script>
</body>
</html>